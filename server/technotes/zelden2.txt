This is my second time writing out stuff on Zelden. I'll import the older documents I wrote out at some point.

So I've decided that, in the interest of getting the server/client working as soon as possible, I'm not going to have the server store its data in JPath. I think I'm going to use a traditional relational database instead, and switch over once JPath is in a workable state.

So I've been using Quassel recently and it's given me some ideas. One huge idea is the chat monitor; it's a view that shows all messages received, no matter what user, channel, or account they're from. It's an interesting concept that I think I'm going to write into Zelden too.

And speaking of that: views. This is a generalized notion of a conversation that I'm slowly coming up with. The idea would be that a view shows a series of messages, and optionally provides a space for writing new messages. It would also optionally provide a space indicating users contributing to that view; this would be used, for example, in channels to show the channel members; it would be hidden in normal

Conversations would be a particular type of view; the chat monitor would also be a view, but one without support for sending messages. Plugins could also provide views where they could log information and perhaps allow the user to instruct them to do things by sending messages of a particular format.

Then I'm also thinking there should be a notion of screens, which are like views but without the whole messaging idea on top of them. Screens would simply display a block of HTML, with the ability for said HTML to communicate with the server-side plugin that created it via certain JavaScript functions. Screens need to be thought out more.

Then there are settings. These are going to be nearly identical to the notion of configuration variables present in JZBot. There's a root settings folder, which contains other settings and folders. Folders can contain arbitrarily-nested folders. Settings have a name and a description; I may add support for a longer description at some point, but for now, there's just going to be the name and a short-ish description.

Settings have an identifier as well, which is used when referring to the setting in code. Settings also have a type; I'm thinking that for now this should be one of bool (a boolean; would most likely show up as a checkbox), integer (a whole number; text field in desktop clients and spinner in the Android client), decimal (text field that's checked when the OK button is clicked), text (a single-line piece of text), essay (a multi-line piece of text), password (a single-line piece of text that's masked when displayed to the user, although I'm thinking there should be a checkbox that the user can temporarily check to see the contents of the password field), and option (a choice from among a list of predefined options; in the future, I may add support for custom values to be set by the user for some certain fields).

Settings also have a flag indicating whether they can contain multiple values; settings that can contain multiple values allow ordered lists of values of the setting's type.

Non-list settings have a default value, which will be used as the value for the setting if it's unset (and clients should provide a UI for unsetting settings). Such settings that are currently set are stored as if they were lists of one value, and such settings that are currently unset are stored as if they were lists containing no values. Settings that become lists from non-lists have one value if they were set and zero values if they were unset. Settings that become non-lists from lists take the value of their first item but preserve the rest of the items in the database until the user manually unsets the setting, which clears the items from the list. So list settings that have no values are inherently unset, and as such no UI is provided to unset a list setting, unless the client wants to provide one in which case it's essentially a shortcut for clearing the list as this is the action that the server takes when asked to unset a setting.

For settings that are of type option, there's also an additional property: the list of options for the setting. Each option in this list consists of two values: the name of the option (the value that's stored in the database as the setting's value when this option is chosen; also the value passed through code when this option is chosen), and the option's label (the text that's shown to the user when they're choosing the option value). The list of valid options can be added to and removed from in real time by a plugin. Option settings cannot be set to a value not present in the setting's list of choices, and if a particular option is removed and the option setting currently held that value, its value appears to be changed to be the default.

Note that if an option setting does not have a default value, or if the default value is not a valid option, the option will be unset. This is perfectly valid for an option to be unset, and the only way to create an option setting that cannot be unset is to provide it with a default that is in the list of the setting's valid options.

Settings also have a flag indicating whether or not they're enabled. This, like most other things about settings, is not stored in the database, but it is sent to the client, and clients should gray out disabled options. Such options should be used in preference to simply deleting an option and re-creating it when it's a relevant option, for two reasons: 1, this will typically look cleaner, since things don't have to constantly shift around, and 2, the user can then see that the option actually exists, and they can see the option's name and description (although they will be unable to edit it).

The idea with enabled/disabled options is that an option setting can be created with one of its options being "other", and setting it to that option would cause another setting just below it to enable and allow the user to enter a custom value.

Folders, like any other setting, can be disabled; disabling a folder implicitly disables every setting contained within it (including other folders and their contained settings). It's up to a particular client whether or not to allow the contents of such folders to be viewed; like other settings, however, said contents cannot be edited.

The server will actually enforce that disabled settings cannot be modified. I haven't decided yet whether or not the server will simply ignore such a request or whether it will send a response to the client saying that the setting has been disabled. I'm leaning toward the latter so that the client can pop up a message telling the user that the setting was disabled.

The server will also enforce that a setting cannot be set to a value that's not valid for the setting's type; this includes option settings, meaning that the server will not allow a client to set a setting to a value not in the list of options for that setting if the setting is of type option.

If a setting changes types and the new type enforces a constraint that the current value does not satisfy (for example, the setting was formerly text and the current value is some string of characters, but the setting has now become an integer setting), the setting will be reported as currently being set to its default value.

Also, quick note: while settings can change their type, they cannot change whether or not they are a folder, i.e. non-folder settings cannot become folders and folder settings cannot become non-folder settings. The database storage for settings will ensure that such a thing does not cause conflicts (folders aren't actually stored in the database; settings are instead stored with their full path spelled out, although I may change this if it ends up taking up too much space).

Another quick note: the function used for sticking a new value into a setting can throw an exception of a certain to-be-determined class that indicates that the value to be set is not valid. StoredSetting would allow listeners to be provided when an instance of it is created that are notified of the new value before it's set; these can throw a not valid exception if they want to, and it will propagate it out. If a message arrives from a client indicating that a particular setting is to be altered, and an exception is thrown, a message will be sent back to the client with the exception's detail message; clients can then use that to display a "This setting could not be modified: insert exception message here" sort of message.

A third quick note: I'm also thinking that settings should not be able to change type while actually existing. By that, I mean that I don't think it should be possible to change the type of a setting that Zelden itself is already aware of; the setting would have to be unregistered and then re-registered under its new type. This is just a thought.



Ok, I think that about works out the settings system. I'm not going to get too much into implementation yet, but I think that it would be nice if settings were represented in the server as instances of classes that could be defined on a per-plugin basis; StoredSetting would be a setting class provided by Zelden that stores its data to the database. The ability of plugins to provide their own settings classes would mean that settings don't necessarily need to be tied directly to the database; some plugins might end up finding this useful. The idea would be that settings have functions for registering listeners to be notified when the setting's value, options, type, name, description, etc change, and a default ABC called Setting would provide these methods and methods such as fire_value_changed() for subclasses to call. Settings that are folders would have listeners to listen for settings within said folders being added or removed, and probably listeners for listening for child settings being reordered.



So now, of course, we hit upon a huge topic: there's beginning to be a significant overlap between a lot of Zelden storage things and the settings storage mechanism. So the question is: what should be stored where?

You know what... Before I answer all of that, I'm going to write out stuff about all of the other aspects of how Zelden works, and see if I don't have a clearer answer by then.

(Also, I need to think of how clients should store client-specific settings, and whether or not the server should be able to manage any client-specific settings at all; such a thing would be useful if a user wanted to open a client of the same type on a different computer and preserve their former settings; perhaps a number of client profiles should be creatable, which each govern the configuration of a client, and clients can switch between client profiles if they choose to make use of that mechanism. It's something to think about.)

So... We have accounts. Accounts are the same as in Pidgin: they're the details needed to connect as a particular user to a particular chat system. For most protocols, this would include a server, a username, and a password. Each account should have a group of settings tied to it; individual protocol plugins would register settings like server, usernamd, and password, and other protocols could register their own per-account settings as needed.

Hm... Now I need to think about the fundamental differences between users and contacts. There was a suggestion a while back (I think by Matias) to create a contact for every user interaction that occurs, the rationale being that said interaction would be logged anyway and so creating a hidden contact on top of it couldn't be that expensive. I rather like this idea since it has amortized constant space overhead; events triggered by a contact would outweigh the space taken up by the contact record itself. The only potential problem would be that users included simply because of their being present at a channel upon join would a significant amount of overhead; a user spamming a channel with repeated joins using different nicks would likewise trigger this problem.

Of course, the other problem is that an IRC nickname does not always distinguish a user from another, since nicknames are, in general, volatile. This making me think more and more that contacts should not be implicitly created.

So, in that case, what exactly are contacts?

Or rather, what sort of things do contacts need to be able to do?

Well...

It should be possible to start a conversation with a contact, which means that the contact should have enough protocol-specific information to identify a single user on a single account. (For example, IRC requires only the user's nick, while XMPP requires only the user's JID.)

It should also be possible to attribute any messages or events that pertain to a particular contact to that contact.

So it seems like the information that defines a contact should be the same as the information that defines a user for the sake of private messaging.

Does that work with existing protocols? Let's see...

IRC: A user/contact is identified based on their nick. Conversations can be initiated with them based on this, messages sourced from that nick can be identified, and so on. This sounds like a workable idea.

XMPP: A user/contact is identified based on their JID. This also satisfies all of the requirements: messages coming from a resource under that JID are attributed to that contact, and messages sent to that contact would be sent to the JID. That works.

AIM: A user/contact is identified based on their screen name. That works just like the others do.

BZFlag: A user/contact is identified based on their BZFlag name, with an extra piece of information stored in each message and event that indicates whether or not the user was identified when that event happened. That also seems to work out just fine.

Those are the most important protocols to support in Zelden. So I think this will work out just perfect.

Private message windows should function with the same information, as should colorizing of users' names in messages sent by them.

So... Then we run into another question: aside from the account with which a particular user is associated, can the data needed to uniquely identify a user within an account be specified as a single string, or does it need to be a more complex structure?

IRC would use the nick, XMPP would use the JID, AIM would use the screen name, and BZFlag would use the username. Skype would use the username as well. Mumble, if support for Mumble is ever added, would also use the username. So I think we're good for now with just using a single string to identify a user.

Ok, that just about works out the identifying information of a user. Now what about chat rooms?

Actually, I'm thinking that they should work pretty much the same way. Any given room can be identified by two things: the account to which it belongs, and the name of the chat room. For IRC, this name would be the channel name. For XMPP, this would be the address of the chat room (name@conference.example.org). For BZFlag, this would be one of a few hard-coded strings such as observer, all, admin, etc.

There would be some way for every protocol to verify that a particular chat room which is to be joined or added to the chat room list is of a valid format. XMPP chat rooms must follow the format x@y, IRC chat rooms must start with one of the channel prefixes (#!& and a few others; I don't remember the full list right now), and BZFlag chat rooms must be named one of a few constant strings as mentioned in the previous paragraph.

So now I'm remembering that there are a ton of protocol-specific things that may need to be done (like subscribing in XMPP, or custom XMPP commands, or kicking users with a specified duration and message in BZFlag). And that's making me start to think about two separate ways to go about addressing this, both of which would work together: forms and screens.

I mentioned screens near the top of this file; I'll get to them in a second.

I'll also get to forms in a second, after I discuss my idea of actions.

So my thing I'm thinking about with actions is that things like contacts and accounts and chat rooms and users and things like that could have actions associated with them. Actions have a name, optionally a description, and some information describing the action to the server so that it can dispatch it to the correct plugin and so that the plugin knows what to do. When an action is triggered, a message will be sent to the server, providing information about the action and the object on which it was fired. The server then uses this to route the action to the appropriate plugin, which will come up with a response.

The response can be one of five different types:

1: A null response; nothing will happen. The client should essentially discard this response and not show the user anything.

2: A notification response. This will contain a short message, which the client should notify the user of. I expect the Android client to show a message of this type as a toast.

3: A message response. This will contain a piece of text, similar to notification responses; the difference is that the text is expected to be longer, and so it will be shown as an alert box that the user can dismiss. I expect both notifications and message responses to be shown the same in the desktop client for now.

4: A form response. This will contain some instructions, a list of fields, each field having a name, a label, a default value, and an optional description, and a list of actions, each of which consists of a name and a label. The fields are shown as text boxes; once the user fills them out, and presses one of the action buttons, the action will again be fired, this time including the submitted form information. (I'm thinking hidden fields should also somehow be possible.) If the user hits cancel, this is sent to the server and the form is discarded. The response from the server in that case can only be of type 1, 2, or 3.

5: A screen response. This provides the HTML to show in a screen and the information needed to wire up that screen's javascript objects to the plugin to which the action was dispatched. A screen showing said HTML will then be displayed.

I'm also thinking about adding a sixth type of response, which would need some more thought:

6: A settings response. This instructs the client to display a particular settings page for a particular object. This could be used by an action that creates a new settings folder to actually open said folder to allow the user to further configure it. An example I was thinking of would be an alarm plugin for Zelden that sets off an insistent notification (a notification that repeats a certain sound over and over again until it's dismissed, and one that probably hovers over the user's screen on a desktop client) whenever the time specified by any alarm happens; there would be a global action called "create alarm" or some such thing, and this would create a settings folder for that alarm and then switch to it in the client.

(I've been thinking about the Android client during design of this system, so I need to make sure that all these ideas work for the desktop client too.)

That also gives me an idea: allow settings folders to contain actions, which, when tapped, trigger certain actions on that settings folder. Alarms could be implemented entirely in terms of settings, with an action in the "Alarms" folder called "Create alarm" that creates a new alarm folder and switches to it, and an action in each alarm folder called "Delete alarm" that would respond with a form containing the instructions "Are you sure you want to delete this alarm?" and a response titled "Delete" or some such thing. (and note on settings: if a setting folder that a client is currently visiting is deleted, it should switch to the parent folder, unless it's been deleted in which case it should switch to its parent folder, and so on.)

That might actually allow accounts to be implemented in terms of settings, but I'm not yet sure if I actually want to do that. More thought on this is needed.

Also, actions within settings folders should be disableable as well, but their disabled state should be tri-value: enabled, disabled, or follow-folder, the latter of which means that the action's enabled state follows that of its parent folder.

(Also, on alarms: the description for each alarm's folder could read "This alarm will go off in 17 hours and 42 minutes" if it's enabled, or "This alarm is disabled" if it's disabled. This also highlights the need for the ability to alter the description of a setting or folder live. There should, however, be a setting provided by the alarm plugin that can be used to specify how often these descriptions should be updated in order to prevent tons of updates from draining the battery of Android clients.)

So now I'm wondering if I can make this notion of actions into a concept that can be used throughout other parts of Zelden as well. Specifically, I'm wondering what would happen if notifications had actions attached that were triggered whenever the notification was clicked.

That would require a seventh response to an action: the ability to open up a particular view. And views need to be specified further as well.

But before I get on to views, and how the action system might be generalized, I'm going to think a bit about notifications.

So... what are notifications and how do they work?

Notifications are things that can be created by Zelden itself or by a particular plugin. They are shown on all clients; there's intentionally not a way to create a notification that shows up on only one client. It will, however, be possible to suppress a notification temporarily on a particular client, although that client can still see it; the notification just would make itself insignificant in a client-specific way.

So... Notifications are things that can be created and shown, and every client shows them. They can be dismissed, which removes the notification from all clients. They can be suppressed for a specific duration, which makes the notification insignificant in a client-specific way; I'm thinking that, for the desktop client, the system tray icon would stop flashing and just display a tiny symbol in one corner if there are only suppressed notifications (as opposed to flashing and displaying a largeish symbol). The android client would do something similar; perhaps have the normal Z icon with a small circle in a corner, instead of the entire Z changing into some message thing or whatever like would happen when a non-suppressed notification is present.

It should be possible for notifications to be suppressed for only a specific client, and to that end I'm thinking that clients should have names. When you set up a connection to a particular Zelden Server, you specify the name that the client should connect as. That way the server can identify clients when they reconnect. If a client connects and identifies successfully and a client with the same name is already connected, the server will disconnect that client, and warn the entire system that a duplicate client was just removed from the network via a notice to some system view or something.

So, notifications are created with a unique integer id and some more info that will probably be stored as a JSON object so that I can change it in the future. The information, right now, is the text of the notification, the plugin that created it (or some special value if Zelden itself created it; I'll get to situations where this can happen in a bit), and a plugin-specific object providing more information about the notification.

Actually... I'm getting too much into details. Let me back up and think of what I want notifications to be able to do.

I want it so that when a highlight or a private message arrives, a notification can be sent out to all connected machines. These notifications would also be persistent, meaning that they would be stored in the database so that in the event of a server crash, they would still be available to clients. And, of course, I want it so that a client connecting to a server will see all currently-existing notifications, even if it wasn't connected when they happened.

I want the ability for a user to put a notification into a suppressed state, where it still exists and it's still possible to view it from a client but where it's not very obvious that it's there and where the client doesn't take exorbitant measures that it normally would with normal notifications (like toasts and flashing icons) to let the user know that it's there. I want it to be possible for a user to suppress a notification either globally or just for the client that they're on, and I want it to be possible for a user to suppress the notification for other computers as well. I want notifications to be suppressable like this only for a specific duration (or more accurately, until a specific date) after which they return to normal. I want some way to be able to suppress notifications at creation time via plugins so that, for example, a plugin can suppress notifications for some clients while others are not idle. (and clients should report how long they've been idle.)

So I just thought of some more ideas while taking my shower today (2011.08.11). It should be possible to create ongoing notifications. These are similar in intent to Android's ongoing notifications; unlike Android's ongoing notifications, however, Zelden ongoing notifications have some functional differences from Zelden normal notifications. In Zelden, only normal notifications are stored in the database; ongoing notifications are volatile, like the settings schema, and therefore must be recreated after a server restart.

Notifications can be switched from normal to suppressed by the user werfself, and set to suppressed on some machines while normal on others. Ongoing notifications, however, are ongoing no matter what, and this can't be changed by the end user. The idea would be that ongoing notifications could be used for things like a plugin that automatically suppresses things based on channel; it could show what channels it's currently auto-suppressing as ongoing notifications. It would store that list on disk every time it's updated, and when the plugin loads, it would re-create the ongoing notifications for it. (except that I think it will just use a single ongoing notification to mention all of the channels/users/accounts that are currently on auto-suppress.

It should also be possible to group notifications by the plugin that created them. I might also make it possible to group notifications by some other criteria that could be specified by each plugin in the future.

Anyways... So I want there to be ongoing notifications that don't bug the user but let them know about all of the ongoing things that they should be aware about.

So I've decided that I want it to be possible to suppress a notification for an infinite amount of time, the idea being that it remains suppressed until it's dismissed or until the user unsuppresses it by hand.

I also want it to be possible for plugins to attach arbitrary information to a particular notification, including ones that they didn't create. I'm not going to concentrate really hard on this since I had a reason for doing it but I completely forgot said reason, but I just want to make it at least possible.

So now I can't decide whether notification suppression should be stored on disk or simply in memory. Some applications of suppression, such as automatically suppressing notifications to a particular machine instead of...

So I mentioned this to James Stoker, and he suggested doing a combination of both: have notifications be suppressed only in memory, but allow plugins to attach data to the notification that's persistent. I'm thinking notifications will have get_user, set_user, and list_user for getting, setting, and listing user-defined JSON values. Each one of those calls will update the notification in the database.

Notifications, then, can have potentially several different suppressions attached to them. So long as at least one suppression is present on a notification, it remains suppressed. Each suppression tracks the plugin that added it and the duration that the suppression should last for, which can potentially be 0 to represent an indefinite suppression. Zelden will automatically remove each suppression as its duration elapses, and suppressions can be manually removed by plugins.

In addition to specifying a plugin and a duration, and any other attributes that the plugin might assign to the suppression object (and all of the suppress methods will take a dict of such attributes to assign on creation of a suppression), a suppression also tracks a specific client for which it applies, by name. If this is None, the suppression applies for all computers. Suppressions can be created for computers that aren't currently connected or even for those that don't exist; such suppressions won't have any effect until such a computer connects or is created.

Each suppression currently active is sent out with every notification. This allows the client to show information about suppressions to the user, if they have some advanced mode enabled that would cause it to be shown. The server also computes whether or not those suppressions mean that the notification should be suppressed on that client so that the client doesn't have to.

Notifications would therefore need to be able to allow actions to be attached to them. A plugin for manual notification suppression would then be present that adds a "Suppress" action to notifications, and an "Unsuppress" action to notifications that it has suppressed. It would probably show a smallish instruction or some such thing below that if the notification were being suppressed by another plugin indicating such so that the user knows that they need to do something else to unsuppress it.

Hm... Now I'm thinking it might be good if there was a standardized manual suppression-for-a-particular-duration mechanism so that automatic channel-based suppression could be unsuppressed by the manual plugin. This needs more thought...

Actually, let me get back to the "what do I want this to be able to do" thing and see if I can't work something out. So, some things that might or might not be written as plugins that I want to be happenable:

-----------------------------

1: I want notifications to occur when a highlight or a message arrives for my username, and possibly some other strings on a per-account or global basis.

2: I want notifications to be persistent, so that if I have an active notification, and I reconnect or restart Zelden Server, I will still see that notification.

3: I want my manually-suppressing a notification to be persistent, so that if I suppress a notification globally or on a specific computer for a day, then disconnect or restart Zelden Server, that notification will still be suppressed until a day from when I originally suppressed it. (Thus suppression durations should be stored as dates to unsuppress at, not remaining durations.)

4: I want to be able to suppress a notification for all clients for, say, a day.

5: I want to be able to suppress a notification on my android for, say, a day, or indefinitely, but not have it suppressed on my computer.

6: I want to be able to suppress a notification on my computer from my android, exactly the same as I would be able to if I were actually at my computer.

7: I want to be able to unsuppress a notification for any particular computer, or for all computers, from any computer. If I unsuppress a notification for a single computer, I'm ok with it being converted to a computer-specific-suppressed notification that happens to be suppressed for all other computers that the server has ever seen.

8: I want to be able to suppress a notification on my android for, say, a day, and then suppress it on my computer (or suppress it on my computer from my android) for, say, two days.

9: I want to be able to configure Zelden so that it will suppress notifications on my android as long as my laptop is not idle, and by "not idle" I mean that there's been mouse movement at my laptop in the last five minutes.

10: I want to be able to set particular channels and PMs to automatically suppress notifications coming from highlights or messages in said channels or PMs. I also want to have the option of setting this to a whitelist configuration, where notifications are suppressed from said channels/pms except for ones on the whitelist. I want the ability to extend this in the future to be able to specify specific computers for each channel for which notifications should be suppressed. *

11: I want to be able to specify that notifications are to be suppressed for a certain device during certain times or situations, but I want this to be implementable via a plugin so that said times/situations can be customized. Notifications suppressed because of this should be unsuppressed at the end of this delay. I'm ok with making it so that notifications can't be unsuppressed during this time. (James Stoker specifically wants the ability to suppress all notifications for his laptop when he's in certain locations.)

12: I want the channel or pm corresponding to a notification to become switched to when I dismiss that notification.

13: I want a way to visit the channel or pm corresponding to a notification without dismissing it.

14: I want the channel or pm corresponding to a notification to scroll to the message that triggered the notification when I dismiss the notification or instruct the notification to open the channel/pm associated with it.

15: I want to be able to write a calendar plugin that provides some sort of global menu item which opens a screen where the user can add and edit calendar items. I want each calendar item, when clicked, to open a corresponding settings page for the newly-created calendar item that only shows that item's folder and the settings contained within it. I want calendar items to cause notifications at the time when they're supposed to trigger their alarm. I want each calendar notification to dismiss itself and open up a screen showing the corresponding calendar item when the notification is clicked, and I want an additional menu item to be addable to the calendar notification that opens up the corresponding calendar item without dismissing the notification.

16: I want the ability to create a plugin that allows me to set alarms in some fashion. I want said alarms to be able to provide notifications that keep beeping or making noise until I shut them off, I.E. they don't go away

-----------------------------

* This made me think of an excellent use for alternate implementations of Setting besides StoredSetting: each channel could have two settings, "suppress notifications" and "don't suppress notifications" that blacklist and whitelist that channel, respectively, and then there would be a global setting for choosing whether the blacklist or whitelist is used. To allow for an easy way to see if any channels are blacklisted or whitelisted and modify them all together, two global settings, "suppressed channels/pms" and "non-suppressed channels/pms" could be present, each one being a multi-value multiple choice setting, which is actually provided by a custom subclass of Setting that backs the available choices from the list of channels and pms and that backs the current values from those channels and pms which have their "suppress notifications" and "don't suppress notifications" settings set, respectively. It would most likely not allow reordering of values and complain if values were reordered via a toast, and it would also most likely not allow duplicate values. Anyways, back to the topic at hand.

I just trimmed down a bunch of stuff here; look back in Git history to find it.

So, we have a concept of actions and reactions and notices. Actions are things consisting of a name, a label, a description, and a list of reactions that can be attached to various objects within Zelden such as notifications, channels, users, Zelden itself (i.e. global actions), and so on. Reactions are things to do on the client side; they can't change any server side state themselves. Types of reactions include forms, toasts, links to settings pages (specifying the root of the hierarchy to display and the folder to select), notices, and so on. Notices are a packet and a corresponding type of reaction that causes said packet to be sent to a certain plugin with a certain data object and a source object specific to what caused the notice reaction to be triggered. Thus the only way for an action to effect any server-related state change is for it to contain a notice reaction and have the server-side plugin receiving the notice effect such server-side changes. Each reaction type contains an associated JSON object providing more information specific to that particular reaction.

Ok, with that out of the way, let's see if we can design a notification system that fulfills all of the above requirements.

Notifications are things that are created and stored in the server-side database. Each notification has a unique integer id. It also has the name of the plugin that created it, a label, a description, an insistent flag, and a JSON userland object. These are all stored on disk. Additionally, a separate table containing all the manual suppressions that apply to the notification is stored; each entry in that table specifies the computer for which the suppression applies (there must be only one suppression per computer, and only one suppression that does not specify a computer). Notifications also have a list of actions and a list of default reactions which are run when the notification itself is simply clicked; these could be thought of as making up the "default" action for the notification. These actions and reactions, however, are not stored on disk. Zelden won't ever send out a notification without any reactions attached to it; if the reaction list ever becomes empty (and when it starts out empty, as it will when Zelden loads), Zelden will attach a reaction that opens a form telling the user that no reactions are attached and would they like to dismiss the notification, and if they hit yes a notice will be sent to Zelden which will cause it to dismiss the notification.

Notifications can be created and dismissed only on the server-side. They can be created and dismissed by any plugin. This satisfies #1 on the list of objectives for notifications.

The current list of notifications is sent to each client when it connects, and notifications, as mentioned above, are persisted in the database, with plugins restoring actions and the default set of reactions as needed. This satisfies #2 on the list.

A UI will be presented to clients whereby a suppression can be added for a particular client, or for all clients, or a particular suppression (or all suppressions) removed. Plugins will have access to the mechanism for doing this as well. Adding a suppression for a computer that already has one will cause the existing one to be replaced. This satisfies #3.

A suppression can be added that applies to all computers. This satisfies #4.

A suppression can be added that applies only to a specific computer. This satisfies #5.

The user would be able to choose that the suppression they are creating should apply to a different computer than the one from which they are connecting. This satisfies #6.

Arbitrary suppressions can be removed from any client. This satisfies #7.

Different suppressions can have different durations. This satisfies #8.

Now we get into another feature: automatic suppressions. The above suppression mechanism I'm calling manual suppressions; automatic suppressions are suppressions that only persist as long as a particular instance of Zelden Server is running, same as actions and reactions on notifications. They cannot be added, modified, or removed by the user; they can only be added, modified, and removed by plugins, though the user will be able to see that they are present. They have the same features as manual suppressions other than that, except that multiple automatic suppressions may exist for a particular computer, and each one has a name, the plugin that created it, and a userland object which can be used by the plugin to tell multiple instances apart.

A plugin could then be written which monitors my laptop's idle status and applies an automatic suppression to all notifications for my android when it is idle but removes said suppression when it is no longer idle. It would also listen for notifications being created and apply said suppression to them if my laptop is currently idle. This satisfies #9.

Plugins would have access to the manual suppression facility as well. This would satisfy #10 if I implement it to create manual suppressions as I plan on doing so that users can remove the suppression if they want; otherwise, #10 would be satisfied by the automatic suppression system.

The automatic suppression mechanism is available to plugins (and, as mentioned above, /only/ available to plugins, not to the end user). This satisfies #11.

Notifications can have reactions attached to them. The first such reaction could switch to a particular channel (there would be a type of reaction that opens a particular channel or pm) and the second reaction could notice the server with a particular notice to which the plugin that created the notification would respond by dismissing the notification. This satisfies #12.

A custom action can be attached to a notification that only has the reaction that opens the corresponding channel, without noticing the server to dismiss the notification. This satisfies #13.

The reaction specifying that a particular channel should be opened would likely have a particular entry in its associated information object specifying that a particular message should be scrolled to, and perhaps that a border should be shown around said message for a few seconds. This satisfies #14.

A particular type of reaction would be present that opens up a screen with certain parameters passed to said screen. This, along with the facilities that satisfy #12 and #13, would satisfy #15.

Notifications have an insistent flag that specifies whether or not the client should continuously bug the user until they dismiss the notification, or until the insistent flag gets unset. This satisfies #16.

-----------------------------

Wow, I did it. I actually designed the notification system.

And it looks pretty good.

Now... what's next...

























