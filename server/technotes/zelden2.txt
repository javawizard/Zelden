This is my second time writing out stuff on Zelden. I'll import the older documents I wrote out at some point.

So I've decided that, in the interest of getting the server/client working as soon as possible, I'm not going to have the server store its data in JPath. I think I'm going to use a traditional relational database instead, and switch over once JPath is in a workable state.

So I've been using Quassel recently and it's given me some ideas. One huge idea is the chat monitor; it's a view that shows all messages received, no matter what user, channel, or account they're from. It's an interesting concept that I think I'm going to write into Zelden too.

And speaking of that: views. This is a generalized notion of a conversation that I'm slowly coming up with. The idea would be that a view shows a series of messages, and optionally provides a space for writing new messages. It would also optionally provide a space indicating users contributing to that view; this would be used, for example, in channels to show the channel members; it would be hidden in normal

Conversations would be a particular type of view; the chat monitor would also be a view, but one without support for sending messages. Plugins could also provide views where they could log information and perhaps allow the user to instruct them to do things by sending messages of a particular format.

Then I'm also thinking there should be a notion of screens, which are like views but without the whole messaging idea on top of them. Screens would simply display a block of HTML, with the ability for said HTML to communicate with the server-side plugin that created it via certain JavaScript functions. Screens need to be thought out more.

Then there are settings. These are going to be nearly identical to the notion of configuration variables present in JZBot. There's a root settings folder, which contains other settings and folders. Folders can contain arbitrarily-nested folders. Settings have a name and a description; I may add support for a longer description at some point, but for now, there's just going to be the name and a short-ish description.

Settings have an identifier as well, which is used when referring to the setting in code. Settings also have a type; I'm thinking that for now this should be one of bool (a boolean; would most likely show up as a checkbox), integer (a whole number; text field in desktop clients and spinner in the Android client), decimal (text field that's checked when the OK button is clicked), text (a single-line piece of text), essay (a multi-line piece of text), password (a single-line piece of text that's masked when displayed to the user, although I'm thinking there should be a checkbox that the user can temporarily check to see the contents of the password field), and option (a choice from among a list of predefined options; in the future, I may add support for custom values to be set by the user for some certain fields).

Settings also have a flag indicating whether they can contain multiple values; settings that can contain multiple values allow ordered lists of values of the setting's type.

Non-list settings have a default value, which will be used as the value for the setting if it's unset (and clients should provide a UI for unsetting settings). Such settings that are currently set are stored as if they were lists of one value, and such settings that are currently unset are stored as if they were lists containing no values. Settings that become lists from non-lists have one value if they were set and zero values if they were unset. Settings that become non-lists from lists take the value of their first item but preserve the rest of the items in the database until the user manually unsets the setting, which clears the items from the list. So list settings that have no values are inherently unset, and as such no UI is provided to unset a list setting, unless the client wants to provide one in which case it's essentially a shortcut for clearing the list as this is the action that the server takes when asked to unset a setting.

For settings that are of type option, there's also an additional property: the list of options for the setting. Each option in this list consists of two values: the name of the option (the value that's stored in the database as the setting's value when this option is chosen; also the value passed through code when this option is chosen), and the option's label (the text that's shown to the user when they're choosing the option value). The list of valid options can be added to and removed from in real time by a plugin. Option settings cannot be set to a value not present in the setting's list of choices, and if a particular option is removed and the option setting currently held that value, its value appears to be changed to be the default.

Note that if an option setting does not have a default value, or if the default value is not a valid option, the option will be unset. This is perfectly valid for an option to be unset, and the only way to create an option setting that cannot be unset is to provide it with a default that is in the list of the setting's valid options.

Settings also have a flag indicating whether or not they're enabled. This, like most other things about settings, is not stored in the database, but it is sent to the client, and clients should gray out disabled options. Such options should be used in preference to simply deleting an option and re-creating it when it's a relevant option, for two reasons: 1, this will typically look cleaner, since things don't have to constantly shift around, and 2, the user can then see that the option actually exists, and they can see the option's name and description (although they will be unable to edit it).

The idea with enabled/disabled options is that an option setting can be created with one of its options being "other", and setting it to that option would cause another setting just below it to enable and allow the user to enter a custom value.

Folders, like any other setting, can be disabled; disabling a folder implicitly disables every setting contained within it (including other folders and their contained settings). It's up to a particular client whether or not to allow the contents of such folders to be viewed; like other settings, however, said contents cannot be edited.

The server will actually enforce that disabled settings cannot be modified. I haven't decided yet whether or not the server will simply ignore such a request or whether it will send a response to the client saying that the setting has been disabled. I'm leaning toward the latter so that the client can pop up a message telling the user that the setting was disabled.

The server will also enforce that a setting cannot be set to a value that's not valid for the setting's type; this includes option settings, meaning that the server will not allow a client to set a setting to a value not in the list of options for that setting if the setting is of type option.

If a setting changes types and the new type enforces a constraint that the current value does not satisfy (for example, the setting was formerly text and the current value is some string of characters, but the setting has now become an integer setting), the setting will be reported as currently being set to its default value.

Also, quick note: while settings can change their type, they cannot change whether or not they are a folder, i.e. non-folder settings cannot become folders and folder settings cannot become non-folder settings. The database storage for settings will ensure that such a thing does not cause conflicts (folders aren't actually stored in the database; settings are instead stored with their full path spelled out, although I may change this if it ends up taking up too much space).

Another quick note: the function used for sticking a new value into a setting can throw an exception of a certain to-be-determined class that indicates that the value to be set is not valid. StoredSetting would allow listeners to be provided when an instance of it is created that are notified of the new value before it's set; these can throw a not valid exception if they want to, and it will propagate it out. If a message arrives from a client indicating that a particular setting is to be altered, and an exception is thrown, a message will be sent back to the client with the exception's detail message; clients can then use that to display a "This setting could not be modified: insert exception message here" sort of message.

A third quick note: I'm also thinking that settings should not be able to change type while actually existing. By that, I mean that I don't think it should be possible to change the type of a setting that Zelden itself is already aware of; the setting would have to be unregistered and then re-registered under its new type. This is just a thought.



Ok, I think that about works out the settings system. I'm not going to get too much into implementation yet, but I think that it would be nice if settings were represented in the server as instances of classes that could be defined on a per-plugin basis; StoredSetting would be a setting class provided by Zelden that stores its data to the database. The ability of plugins to provide their own settings classes would mean that settings don't necessarily need to be tied directly to the database; some plugins might end up finding this useful. The idea would be that settings have functions for registering listeners to be notified when the setting's value, options, type, name, description, etc change, and a default ABC called Setting would provide these methods and methods such as fire_value_changed() for subclasses to call. Settings that are folders would have listeners to listen for settings within said folders being added or removed, and probably listeners for listening for child settings being reordered.



So now, of course, we hit upon a huge topic: there's beginning to be a significant overlap between a lot of Zelden storage things and the settings storage mechanism. So the question is: what should be stored where?

You know what... Before I answer all of that, I'm going to write out stuff about all of the other aspects of how Zelden works, and see if I don't have a clearer answer by then.

(Also, I need to think of how clients should store client-specific settings, and whether or not the server should be able to manage any client-specific settings at all; such a thing would be useful if a user wanted to open a client of the same type on a different computer and preserve their former settings; perhaps a number of client profiles should be creatable, which each govern the configuration of a client, and clients can switch between client profiles if they choose to make use of that mechanism. It's something to think about.)

So... We have accounts. Accounts are the same as in Pidgin: they're the details needed to connect as a particular user to a particular chat system. For most protocols, this would include a server, a username, and a password. Each account should have a group of settings tied to it; individual protocol plugins would register settings like server, usernamd, and password, and other protocols could register their own per-account settings as needed.

Hm... Now I need to think about the fundamental differences between users and contacts. There was a suggestion a while back (I think by Matias) to create a contact for every user interaction that occurs, the rationale being that said interaction would be logged anyway and so creating a hidden contact on top of it couldn't be that expensive. I rather like this idea since it has amortized constant space overhead; events triggered by a contact would outweigh the space taken up by the contact record itself. The only potential problem would be that users included simply because of their being present at a channel upon join would a significant amount of overhead; a user spamming a channel with repeated joins using different nicks would likewise trigger this problem.

Of course, the other problem is that an IRC nickname does not always distinguish a user from another, since nicknames are, in general, volatile. This making me think more and more that contacts should not be implicitly created.

So, in that case, what exactly are contacts?

Or rather, what sort of things do contacts need to be able to do?

Well...

It should be possible to start a conversation with a contact, which means that the contact should have enough protocol-specific information to identify a single user on a single account. (For example, IRC requires only the user's nick, while XMPP requires only the user's JID.)

It should also be possible to attribute any messages or events that pertain to a particular contact to that contact.

So it seems like the information that defines a contact should be the same as the information that defines a user for the sake of private messaging.

Does that work with existing protocols? Let's see...

IRC: A user/contact is identified based on their nick. Conversations can be initiated with them based on this, messages sourced from that nick can be identified, and so on. This sounds like a workable idea.

XMPP: A user/contact is identified based on their JID. This also satisfies all of the requirements: messages coming from a resource under that JID are attributed to that contact, and messages sent to that contact would be sent to the JID. That works.

AIM: A user/contact is identified based on their screen name. That works just like the others do.

BZFlag: A user/contact is identified based on their BZFlag name, with an extra piece of information stored in each message and event that indicates whether or not the user was identified when that event happened. That also seems to work out just fine.

Those are the most important protocols to support in Zelden. So I think this will work out just perfect.

Private message windows should function with the same information, as should colorizing of users' names in messages sent by them.

So... Then we run into another question: aside from the account with which a particular user is associated, can the data needed to uniquely identify a user within an account be specified as a single string, or does it need to be a more complex structure?

IRC would use the nick, XMPP would use the JID, AIM would use the screen name, and BZFlag would use the username. Skype would use the username as well. Mumble, if support for Mumble is ever added, would also use the username. So I think we're good for now with just using a single string to identify a user.

Ok, that just about works out the identifying information of a user. Now what about chat rooms?

Actually, I'm thinking that they should work pretty much the same way. Any given room can be identified by two things: the account to which it belongs, and the name of the chat room. For IRC, this name would be the channel name. For XMPP, this would be the address of the chat room (name@conference.example.org). For BZFlag, this would be one of a few hard-coded strings such as observer, all, admin, etc.

There would be some way for every protocol to verify that a particular chat room which is to be joined or added to the chat room list is of a valid format. XMPP chat rooms must follow the format x@y, IRC chat rooms must start with one of the channel prefixes (#!& and a few others; I don't remember the full list right now), and BZFlag chat rooms must be named one of a few constant strings as mentioned in the previous paragraph.

So now I'm remembering that there are a ton of protocol-specific things that may need to be done (like subscribing in XMPP, or custom XMPP commands, or kicking users with a specified duration and message in BZFlag). And that's making me start to think about two separate ways to go about addressing this, both of which would work together: forms and screens.

I mentioned screens near the top of this file; I'll get to them in a second.

I'll also get to forms in a second, after I discuss my idea of actions.

So my thing I'm thinking about with actions is that things like contacts and accounts and chat rooms and users and things like that could have actions associated with them. Actions have a name, optionally a description, and some information describing the action to the server so that it can dispatch it to the correct plugin and so that the plugin knows what to do. When an action is triggered, a message will be sent to the server, providing information about the action and the object on which it was fired. The server then uses this to route the action to the appropriate plugin, which will come up with a response.

The response can be one of five different types:

1: A null response; nothing will happen. The client should essentially discard this response and not show the user anything.

2: A notification response. This will contain a short message, which the client should notify the user of. I expect the Android client to show a message of this type as a toast.

3: A message response. This will contain a piece of text, similar to notification responses; the difference is that the text is expected to be longer, and so it will be shown as an alert box that the user can dismiss. I expect both notifications and message responses to be shown the same in the desktop client for now.

4: A form response. This will contain some instructions, a list of fields, each field having a name, a label, a default value, and an optional description, and a list of actions, each of which consists of a name and a label. The fields are shown as text boxes; once the user fills them out, and presses one of the action buttons, the action will again be fired, this time including the submitted form information. (I'm thinking hidden fields should also somehow be possible.) If the user hits cancel, this is sent to the server and the form is discarded. The response from the server in that case can only be of type 1, 2, or 3.

5: A screen response. This provides the HTML to show in a screen and the information needed to wire up that screen's javascript objects to the plugin to which the action was dispatched. A screen showing said HTML will then be displayed.

I'm also thinking about adding a sixth type of response, which would need some more thought:

6: A settings response. This instructs the client to display a particular settings page for a particular object. This could be used by an action that creates a new settings folder to actually open said folder to allow the user to further configure it. An example I was thinking of would be an alarm plugin for Zelden that sets off an insistent notification (a notification that repeats a certain sound over and over again until it's dismissed, and one that probably hovers over the user's screen on a desktop client) whenever the time specified by any alarm happens; there would be a global action called "create alarm" or some such thing, and this would create a settings folder for that alarm and then switch to it in the client.

(I've been thinking about the Android client during design of this system, so I need to make sure that all these ideas work for the desktop client too.)

That also gives me an idea: allow settings folders to contain actions, which, when tapped, trigger certain actions on that settings folder. Alarms could be implemented entirely in terms of settings, with an action in the "Alarms" folder called "Create alarm" that creates a new alarm folder and switches to it, and an action in each alarm folder called "Delete alarm" that would respond with a form containing the instructions "Are you sure you want to delete this alarm?" and a response titled "Delete" or some such thing. (and note on settings: if a setting folder that a client is currently visiting is deleted, it should switch to the parent folder, unless it's been deleted in which case it should switch to its parent folder, and so on.)

That might actually allow accounts to be implemented in terms of settings, but I'm not yet sure if I actually want to do that. More thought on this is needed.

Also, actions within settings folders should be disableable as well, but their disabled state should be tri-value: enabled, disabled, or follow-folder, the latter of which means that the action's enabled state follows that of its parent folder.

(Also, on alarms: the description for each alarm's folder could read "This alarm will go off in 17 hours and 42 minutes" if it's enabled, or "This alarm is disabled" if it's disabled. This also highlights the need for the ability to alter the description of a setting or folder live.) 























